## Завдання 1

- Створіть граф за допомогою бібліотеки `networkX` для моделювання певної реальної мережі (наприклад, транспортної мережі міста, соціальної мережі, інтернет-топології).
- Візуалізуйте створений граф, проведіть аналіз основних характеристик (наприклад, кількість вершин та ребер, ступінь вершин).

## Завдання 2

- Напишіть програму, яка використовує алгоритми `DFS` і `BFS` для знаходження шляхів у графі, який було розроблено у першому завданні.
- Далі порівняйте результати виконання обох алгоритмів для цього графа, висвітлить різницю в отриманих шляхах. Поясніть, чому шляхи для алгоритмів саме такі.

## Завдання 3

Реалізуйте `алгоритм Дейкстри` для знаходження найкоротшого шляху в розробленому графі: додайте у граф ваги до ребер та знайдіть найкоротший шлях між всіма вершинами графа.

## Опис результатів до завдання 2

У даному прикладі результати виконання обох алгоритмів — DFS і BFS — є однаковими, оскільки обидва алгоритми знайшли шлях від вузла "A" до вузла "E":

```
Шлях DFS від A до E: ['A', 'C', 'E']
Шлях BFS від A до E: ['A', 'C', 'E']
```

**Чому шляхи однакові?**
Шляхи для обох алгоритмів однакові через особливу структуру графа:

- Граф є досить простим, з невеликою кількістю вузлів і ребер, і обидва алгоритми мають кілька варіантів для вибору шляху між вершинами.
- Вузол "A" з'єднаний з "C", який, у свою чергу, безпосередньо з'єднаний із "E". Це створює найкоротший шлях між "A" та "E", який обидва алгоритми можуть знайти без необхідності досліджувати інші частини графа.

**Порівняння поведінки DFS та BFS**

1. DFS (Пошук в глибину):
   - **Принцип роботи:** Алгоритм спочатку "занурюється" в глибину, проходячи від одного вузла до іншого до тих пір, поки не знайде ціль або не зустрінеться з тупиком, після чого він повертається назад і досліджує інші шляхи.
   - **В нашому прикладі:** DFS починає з "A", переходить до "C", і далі знаходить "E". Шлях виглядає як ['A', 'C', 'E'], оскільки він рухається по найпершій знайденій гілці, яка приводить до цілі.
2. BFS (Пошук в ширину):
   - **Принцип роботи:** Алгоритм досліджує всі вершини на одному рівні перед тим, як переходити до наступного рівня. Він рухається пошарово від стартової вершини до сусідніх вершин, доки не знайде ціль.
   - **В нашому прикладі:** BFS спочатку досліджує всіх сусідів "A" (це "B" і "C"). Після цього він переходить до їхніх сусідів. В результаті, як тільки BFS досліджує "C", він одразу знаходить шлях до "E", оскільки "C" безпосередньо з'єднаний із "E". Таким чином, найкоротший шлях знову виглядає як ['A', 'C', 'E'].

**Чому шляхи такі?**

- **DFS:** Через те, що алгоритм досліджує глибину, він починає з "A" і йде до "C" (один із перших сусідів), після чого відразу знаходить "E". Цей шлях не обов'язково є оптимальним або найкоротшим для великих графів, але в даному випадку він короткий через структуру графа.

- **BFS:** Алгоритм завжди знаходить найкоротший шлях у графі з ненаправленими і рівноцінними ребрами, оскільки він досліджує рівні від стартової вершини, поступово збільшуючи відстань до кожної наступної вершини. У нашому графі BFS також знайшов шлях ['A', 'C', 'E'], оскільки цей шлях є найкоротшим.

**Різниця в отриманих шляхах:**
У цьому конкретному прикладі різниці немає, оскільки граф простий і шляхи до мети є очевидними для обох алгоритмів. Але в загальному випадку:

- DFS може знайти довший або не оптимальний шлях, якщо він буде заглиблюватися в менш ефективні гілки графа.
- BFS завжди знаходить найкоротший шлях в графах, де всі ребра мають однакову вагу (як у цьому прикладі).

**Висновок:**

- DFS і BFS дають однакові результати в цьому випадку через простоту графа і невелику кількість варіантів вибору.
- BFS гарантує найкоротший шлях, але DFS не завжди оптимальний і залежить від глибини обраної гілки.
- У складніших графах з великою кількістю вузлів і шляхів результати DFS і BFS можуть значно відрізнятися.
